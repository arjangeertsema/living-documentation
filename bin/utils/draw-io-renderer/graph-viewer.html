<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="viewer.min.js" charset="UTF-8"></script>
</head>
<body>
    <script>
        const params = new URLSearchParams(document.location.search);
        const data = params.get("data");

        const div = document.createElement("div");
        div.setAttribute("class", "mxgraph");
        div.setAttribute("data-mxgraph", data);
        document.body.appendChild(div);

        const drawCellState = mxImageExport.prototype.drawCellState;

        mxImageExport.prototype.drawCellState = function(state, canvas) {
            var svgDoc = canvas.root.ownerDocument;
			var g = (svgDoc.createElementNS != null) ?
					svgDoc.createElementNS(mxConstants.NS_SVG, 'g') : svgDoc.createElement('g');
			g.setAttribute('id', 'cell-' + state.cell.id);

			// Temporary replaces root for content rendering
			var prev = canvas.root;
			prev.appendChild(g);
			canvas.root = g;
			
			drawCellState.apply(this, arguments);
			
			// Adds metadata if group is not empty
			if (g.firstChild == null)
			{
				g.parentNode.removeChild(g);
			}
			else if (mxUtils.isNode(state.cell.value))
			{
				g.setAttribute('content', mxUtils.getXml(state.cell.value));
				
				for (var i = 0; i < state.cell.value.attributes.length; i++)
				{
					var attrib = state.cell.value.attributes[i];
					g.setAttribute('data-' + attrib.name, attrib.value);
				}
			}
			
			// Restores previous root
			canvas.root = prev;
            
        };

        GraphViewer.createViewerForElement(div, (viewer) => {
            const getSvg1 = function() {
                const svg = viewer.graph.getSvg();
                return svg.outerHTML;
            }

            const getSvg2 = function() {
                const graph = viewer.graph;

                var background = null;
                var scale = 1;
                var border = 1;
                
                var imgExport = new mxImageExport();
                var bounds = graph.getGraphBounds();
                var vs = graph.view.scale;

                // Prepares SVG document that holds the output
                var svgDoc = mxUtils.createXmlDocument();
                var root = (svgDoc.createElementNS != null) ?
                        svgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');
                
                if (background != null)
                {
                    if (root.style != null)
                    {
                        root.style.backgroundColor = background;
                    }
                    else
                    {
                        root.setAttribute('style', 'background-color:' + background);
                    }
                }
                
                if (svgDoc.createElementNS == null)
                {
                    root.setAttribute('xmlns', mxConstants.NS_SVG);
                    root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);
                }
                else
                {
                    // KNOWN: Ignored in IE9-11, adds namespace for each image element instead. No workaround.
                    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);
                }
                
                root.setAttribute('width', (Math.ceil(bounds.width * scale / vs) + 2 * border) + 'px');
                root.setAttribute('height', (Math.ceil(bounds.height * scale / vs) + 2 * border) + 'px');
                root.setAttribute('version', '1.1');
                
                // Adds group for anti-aliasing via transform
                // var group = (svgDoc.createElementNS != null) ?
                //         svgDoc.createElementNS(mxConstants.NS_SVG, 'g') : svgDoc.createElement('g');
                // group.setAttribute('transform', 'translate(0.5,0.5)');
                // root.appendChild(group);
                svgDoc.appendChild(root);

                // Renders graph. Offset will be multiplied with state's scale when painting state.
                var svgCanvas = new mxSvgCanvas2D(root);
                svgCanvas.translate(Math.floor((border / scale - bounds.x) / vs), Math.floor((border / scale - bounds.y) / vs));
                svgCanvas.scale(scale / vs);

                // Displayed if a viewer does not support foreignObjects (which is needed to HTML output)
                svgCanvas.foAltText = '[Not supported by viewer]';
                imgExport.drawState(graph.getView().getState(graph.model.root), svgCanvas);

                return mxUtils.getXml(root);
            }

            const svg = getSvg1();

            const result = document.createElement("div");
            result.setAttribute("id", "result");            
            result.innerText = svg;

            document.body.appendChild(result);
        });

    </script>
</body>
</html>